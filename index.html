<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simulonic Dual Warp Simulation</title>
  <style>
    body {
      margin: 0;
      background: black;
      font-family: monospace;
      color: #00ffee;
      text-align: center;
    }
    .canvas-wrapper {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      margin-top: 10px;
    }
    canvas {
      background: black;
      border: 1px solid #00ffee;
    }
    .controls {
      margin-top: 10px;
    }
    .controls label {
      margin: 0 10px;
    }
    .controls input {
      vertical-align: middle;
    }
    button {
      background: #00ffee;
      color: black;
      border: none;
      padding: 6px 12px;
      font-weight: bold;
      margin: 10px 5px;
      cursor: pointer;
    }
    footer {
      margin-top: 60px;
      text-align: center;
      font-size: 1.1em;
      font-weight: bold;
      font-family: 'Orbitron', sans-serif;
      padding: 20px;
      color:white;
    }
  </style>
</head>
<body>

<h2>Simulonic Dual Rendering: Core ‚Üî Chrono-Lattice Projection</h2>

<div class="canvas-wrapper">
  <div>
    <h3>Original Core</h3>
    <canvas id="canvasLeft" width="400" height="400"></canvas>
  </div>
  <div>
    <h3>Chrono Reindexed</h3>
    <canvas id="canvasRight" width="400" height="400"></canvas>
  </div>
</div>

<div class="controls">
  <label>Amplitude:
    <input type="range" id="ampSlider" min="0" max="20" value="8" />
  </label>
  <label>Frequency:
    <input type="range" id="freqSlider" min="1" max="10" value="3" />
  </label>
  <label>Rings:
    <input type="range" id="ringSlider" min="3" max="20" value="12" />
  </label>
  <label>Warp Distance:
    <input type="range" id="distanceSlider" min="0" max="100" value="50" />
  </label>
</div>

<div>
  <button id="modeToggle">Toggle Warp Mode üåå</button>
  <button id="chronoReindex">Reindex Through Chrono-Lattice ‚è≥</button>
</div>

<script>
  const leftCanvas = document.getElementById('canvasLeft');
  const rightCanvas = document.getElementById('canvasRight');
  const ctxL = leftCanvas.getContext('2d');
  const ctxR = rightCanvas.getContext('2d');

  const ampSlider = document.getElementById('ampSlider');
  const freqSlider = document.getElementById('freqSlider');
  const ringSlider = document.getElementById('ringSlider');
  const distanceSlider = document.getElementById('distanceSlider');
  const toggleBtn = document.getElementById('modeToggle');
  const chronoBtn = document.getElementById('chronoReindex');

  let warpMode = false;
  let chronoTransition = false;
  let chronoProgress = 0;
  let chronoSteps = 100;
  let chronoTarget = 0;

  let frame = 0;
  let rings = [];

  function generateRings(n) {
    const maxRadius = 180;
    return Array.from({ length: n }, (_, i) => ({
      baseRadius: ((i + 1) / n) * maxRadius,
      currentRadius: ((i + 1) / n) * maxRadius,
      angle: 0,
      speed: (i % 2 === 0 ? 1 : -1) * (0.01 + i * 0.002),
      baseSpeed: (i % 2 === 0 ? 1 : -1) * (0.01 + i * 0.002),
      color: `hsl(${(i * 30) % 360}, 100%, 50%)`,
      brightness: 50
    }));
  }

  function drawCore(ctx, x, y) {
    ctx.beginPath();
    ctx.arc(x, y, 8, 0, Math.PI * 2);
    ctx.fillStyle = 'white';
    ctx.fill();
  }

  function drawRing(ctx, ring, frame, warpAmplitude, warpFrequency, isWarped, isChronoCopy = false, chronoT = 0) {
    ctx.save();
    ctx.translate(200, 200);
    ctx.rotate(ring.angle);
    ctx.strokeStyle = `hsl(${parseInt(ring.color.match(/\d+/)[0])}, 100%, ${ring.brightness}%)`;
    ctx.lineWidth = 2 + 1.5 * Math.sin(frame / 30 + ring.currentRadius / 50);
    ctx.beginPath();

    const segments = 200;
    for (let i = 0; i <= segments; i++) {
      const theta = (i / segments) * 2 * Math.PI;
      let radius = ring.currentRadius;

      // Elegant morph from original core‚Äôs waveform
      let warpOriginal = warpAmplitude * Math.sin(frame / 20 + theta * warpFrequency + radius / 20);
      let warpFinal = warpOriginal * 1.5;

      let appliedWarp = 0;
      if (isWarped) appliedWarp = warpOriginal;
      else if (isChronoCopy) appliedWarp = warpOriginal * (1 - chronoT) + warpFinal * chronoT;

      radius += appliedWarp;

      const x = radius * Math.cos(theta);
      const y = radius * Math.sin(theta);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }

    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  function animate() {
    ctxL.clearRect(0, 0, 400, 400);
    ctxR.clearRect(0, 0, 400, 400);

    const amp = parseFloat(ampSlider.value);
    const freq = parseFloat(freqSlider.value);
    const count = parseInt(ringSlider.value);

    if (rings.length !== count) {
      rings = generateRings(count);
    }

    // Morph the chrono state
    let chronoT = 0;
    if (chronoTransition && chronoProgress <= chronoSteps) {
      chronoT = chronoProgress / chronoSteps;
      const d = chronoTarget / 100;
      rings.forEach(ring => {
        ring.brightness = 50 + 30 * chronoT * d;
        ring.speed = ring.baseSpeed * (1 + chronoT * d);
        ring.currentRadius = ring.baseRadius * (1 + 0.1 * chronoT * d);
      });
      chronoProgress++;
      if (chronoProgress >= chronoSteps) chronoTransition = false;
    } else if (!chronoTransition) {
      chronoT = 1;
    }

    rings.forEach(ring => {
      ring.angle += ring.speed;
      drawRing(ctxL, ring, frame, amp, freq, warpMode);                    // original core
      drawRing(ctxR, ring, frame, amp, freq, false, true, chronoT);        // chrono-reindexed copy
    });

    drawCore(ctxL, 200, 200);
    drawCore(ctxR, 200, 200);

    frame++;
    requestAnimationFrame(animate);
  }

  toggleBtn.addEventListener('click', () => {
    warpMode = !warpMode;
    toggleBtn.textContent = warpMode
      ? 'Toggle Static Mode üîÅ'
      : 'Toggle Warp Mode üåå';
  });

  chronoBtn.addEventListener('click', () => {
    chronoTarget = parseInt(distanceSlider.value);
    chronoSteps = Math.max(30, chronoTarget);
    chronoTransition = true;
    chronoProgress = 0;
  });

  rings = generateRings(parseInt(ringSlider.value));
  animate();
</script>

<footer>
    Inspired by G√∂sta Greimel's Design and Infosophy,
    Integrated into Hrishi Mukherjee's Simulonic Inertial Null Core Schematic,
    Aligning with Oliver Boeschenstein's OBT. Copyright New Canada 2025. Originally, a joint venture between Austria, Canada, and Switzerland.
</footer>

</body>
</html>